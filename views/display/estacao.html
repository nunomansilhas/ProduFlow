<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Lista de Corte</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #fff;
            color: #000;
            font-family: "Courier New", Courier, monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            -webkit-user-select: none;
            user-select: none;
        }

        header {
            background: #000;
            color: #fff;
            padding: 0.75rem 1.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        header h1 {
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .clock {
            font-size: 1.1rem;
            font-weight: 700;
        }

        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            margin-right: 0.4rem;
        }

        .status-dot.offline { background: #ef4444; }

        main {
            flex: 1;
            overflow-y: auto;
        }

        /* Material group */
        .mat-group {
            border-bottom: 3px solid #000;
        }

        .mat-header {
            background: #111;
            color: #fff;
            padding: 0.6rem 1.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.95rem;
            position: sticky;
            top: 0;
            z-index: 50;
        }

        .mat-total {
            font-weight: 400;
            font-size: 0.85rem;
        }

        /* Cut row with swipe */
        .cut-row {
            position: relative;
            overflow: hidden;
            border-bottom: 1px solid #ddd;
            touch-action: pan-y;
        }

        .cut-row:last-child {
            border-bottom: none;
        }

        .cut-bg {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #10b981;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 1.5rem;
            color: #fff;
            font-weight: 700;
            font-size: 1rem;
        }

        .cut-fg {
            position: relative;
            background: #fff;
            display: flex;
            align-items: center;
            padding: 0.75rem 1.25rem;
            gap: 1rem;
            transition: transform 0.15s ease;
            z-index: 1;
        }

        .cut-row.done .cut-fg {
            background: #f0fdf4;
            text-decoration: line-through;
            color: #999;
        }

        .cut-row.done .cut-qty { color: #999; }

        .cut-qty {
            font-size: 1.5rem;
            font-weight: 700;
            min-width: 60px;
            text-align: right;
        }

        .cut-sep {
            color: #ccc;
            font-size: 1.2rem;
        }

        .cut-dim {
            font-size: 1.2rem;
            font-weight: 700;
            flex: 1;
        }

        .cut-for {
            color: #888;
            font-size: 0.8rem;
            text-align: right;
        }

        .cut-notes {
            font-size: 0.75rem;
            color: #aaa;
            font-style: italic;
        }

        /* Empty */
        .empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem 2rem;
            color: #ccc;
            font-size: 1.3rem;
            flex: 1;
        }

        .empty svg {
            width: 80px;
            height: 80px;
            margin-bottom: 1.5rem;
            fill: #ddd;
        }

        footer {
            background: #f5f5f5;
            border-top: 1px solid #ddd;
            padding: 0.4rem 1.25rem;
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: #999;
        }

        /* Print */
        @media print {
            header { position: static; }
            footer { display: none; }
            .cut-bg { display: none; }
            .cut-row.done .cut-fg { text-decoration: line-through; }
        }
    </style>
</head>
<body>
    <header>
        <h1 id="title">Lista de Corte</h1>
        <div>
            <span class="status-dot" id="status-dot"></span>
            <span class="clock" id="clock"></span>
        </div>
    </header>

    <main id="content">
        <div class="empty">A carregar...</div>
    </main>

    <footer>
        <span id="footer-info">ProduFlow</span>
        <span id="footer-count"></span>
    </footer>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const estacaoId = window.location.pathname.split('/').pop();
        const API = '/api/display';

        let estacao = null;
        let materiais = [];
        let done = JSON.parse(localStorage.getItem(`done-${estacaoId}`) || '{}');
        let socket = null;
        let connected = false;

        // ========== SWIPE HANDLER ==========
        function initSwipes() {
            document.querySelectorAll('.cut-row:not(.done)').forEach(row => {
                const fg = row.querySelector('.cut-fg');
                const key = row.dataset.key;
                let startX = 0, currentX = 0, swiping = false;
                const W = row.offsetWidth;
                const THRESHOLD = W * 0.4;

                function onStart(e) {
                    if (row.classList.contains('done')) return;
                    startX = e.touches ? e.touches[0].clientX : e.clientX;
                    currentX = 0;
                    swiping = true;
                    fg.style.transition = 'none';
                }

                function onMove(e) {
                    if (!swiping) return;
                    const x = e.touches ? e.touches[0].clientX : e.clientX;
                    currentX = Math.min(0, x - startX);
                    fg.style.transform = `translateX(${currentX}px)`;
                }

                function onEnd() {
                    if (!swiping) return;
                    swiping = false;
                    fg.style.transition = 'transform 0.2s ease';

                    if (Math.abs(currentX) > THRESHOLD) {
                        fg.style.transform = `translateX(-${W}px)`;
                        setTimeout(() => {
                            row.classList.add('done');
                            fg.style.transform = 'translateX(0)';
                            done[key] = Date.now();
                            localStorage.setItem(`done-${estacaoId}`, JSON.stringify(done));
                            updateCount();
                            playTick();
                        }, 200);
                    } else {
                        fg.style.transform = 'translateX(0)';
                    }
                    currentX = 0;
                }

                fg.addEventListener('touchstart', onStart, { passive: true });
                fg.addEventListener('touchmove', onMove, { passive: true });
                fg.addEventListener('touchend', onEnd);
                fg.addEventListener('mousedown', onStart);
                fg.addEventListener('mousemove', onMove);
                fg.addEventListener('mouseup', onEnd);
                fg.addEventListener('mouseleave', onEnd);
            });
        }

        function playTick() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.connect(g); g.connect(ctx.destination);
                o.frequency.value = 1200;
                g.gain.value = 0.15;
                o.start(); o.stop(ctx.currentTime + 0.08);
            } catch(e) {}
        }

        // ========== DATA ==========
        async function loadStation() {
            try {
                const r = await fetch(`${API}/estacoes/${estacaoId}`);
                if (r.ok) estacao = await r.json();
            } catch(e) {}
            estacao = estacao || { nome: 'Estacao', icone: 'fa-cog' };
            document.getElementById('title').textContent = `Lista de Corte — ${estacao.nome}`;
        }

        async function loadMateriais() {
            try {
                const r = await fetch(`${API}/estacoes/${estacaoId}/materiais`);
                materiais = r.ok ? await r.json() : [];
            } catch(e) {
                materiais = [];
            }
        }

        // ========== RENDER ==========
        function fmt(n) {
            n = parseFloat(n) || 0;
            if (n === Math.floor(n)) return n.toString();
            return n.toFixed(2).replace('.', ',');
        }

        function render() {
            const el = document.getElementById('content');

            // Flatten all cuts and clean old done entries
            const allKeys = new Set();
            for (const mat of materiais) {
                for (const c of mat.cortes) {
                    allKeys.add(`${mat.material}|${c.medida}|${c.produto}`);
                }
            }
            // Remove done entries that no longer exist
            for (const k of Object.keys(done)) {
                if (!allKeys.has(k)) delete done[k];
            }
            localStorage.setItem(`done-${estacaoId}`, JSON.stringify(done));

            if (!materiais || materiais.length === 0) {
                el.innerHTML = `
                    <div class="empty">
                        <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
                        Sem cortes pendentes
                    </div>
                `;
                updateCount();
                return;
            }

            let html = '';
            for (const mat of materiais) {
                html += `<div class="mat-group">`;
                html += `<div class="mat-header">
                    <span>${mat.material}</span>
                    <span class="mat-total">${fmt(mat.total)} ${mat.unidade}</span>
                </div>`;

                for (const c of mat.cortes) {
                    const key = `${mat.material}|${c.medida}|${c.produto}`;
                    const isDone = !!done[key];

                    html += `
                        <div class="cut-row ${isDone ? 'done' : ''}" data-key="${key}">
                            <div class="cut-bg">FEITO ✓</div>
                            <div class="cut-fg">
                                <span class="cut-qty">${c.pecas}x</span>
                                <span class="cut-sep">—</span>
                                <span class="cut-dim">${fmt(c.medida)} ${mat.unidade}</span>
                                <span class="cut-for">${c.produto}${c.notas ? '<br><span class="cut-notes">' + c.notas + '</span>' : ''}</span>
                            </div>
                        </div>
                    `;
                }

                html += `</div>`;
            }

            el.innerHTML = html;
            initSwipes();
            updateCount();
        }

        function updateCount() {
            const total = materiais.reduce((s, m) => s + m.cortes.length, 0);
            const feitos = Object.keys(done).length;
            document.getElementById('footer-count').textContent =
                total > 0 ? `${feitos}/${total} concluidos` : '';
        }

        // ========== SOCKET ==========
        function initSocket() {
            try {
                socket = io();
                socket.on('connect', () => {
                    connected = true;
                    socket.emit('join-station', estacaoId);
                    document.getElementById('status-dot').classList.remove('offline');
                });
                socket.on('disconnect', () => {
                    connected = false;
                    document.getElementById('status-dot').classList.add('offline');
                });
                ['order-started', 'order-station-changed', 'order-completed', 'order-completed-station'].forEach(evt => {
                    socket.on(evt, async () => {
                        await loadMateriais();
                        render();
                    });
                });
            } catch(e) {}
        }

        // ========== CLOCK ==========
        function updateClock() {
            document.getElementById('clock').textContent =
                new Date().toLocaleTimeString('pt-PT', { hour: '2-digit', minute: '2-digit' });
        }

        // ========== INIT ==========
        async function init() {
            updateClock();
            await loadStation();
            await loadMateriais();
            render();
            initSocket();

            setInterval(updateClock, 1000);
            setInterval(async () => {
                if (!connected) {
                    await loadMateriais();
                    render();
                }
            }, 30000);
        }

        init();
    </script>
</body>
</html>
